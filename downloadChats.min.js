class t extends Error { constructor(t) { super(t), this.name = "ValidationError"; } getCustomErrorMessage() { return `ValidationError: ${this.message}`; } } function formatConversationMarkdown(e, n = !0) { try { !function validateConversation(e) { if (!e) throw new t("The conversation object cannot be null or undefined."); if ("object" != typeof e || Array.isArray(e)) throw new t("The conversation must be an object."); if (!e.title || "string" != typeof e.title) throw new t("The conversation must have a title of type string."); if (!Array.isArray(e.messages)) throw new t("The conversation.messages must be an array."); e.messages.forEach(((t, n) => { "object" == typeof t && null !== t && "content" in t && "role" in t || console.warn(`Skipping malformed message at index ${n} in conversation "${e.title}".`); })); }(e); const o = function cleanTitle(t) { return t.replace(/^"|"$/g, "").trim(); }(e.title); let r = `## Conversation: ${o}\n\n`; return r += e.messages.map(((t, e) => { const r = "user" === t.role ? "**User:**" : "**Assistant:**"; let i = "" !== t.content.trim() ? function truncateAtCitation(t) { const e = t.indexOf(""); if (-1 !== e) return t.substring(0, e).trim(); return t.trim(); }(t.content) : function handleInvalidContent(t, e, n, o = !0) { return console.warn(`Message at index ${e} in conversation "${n}" contains invalid content.`), o ? null : "(The message contains invalid content)"; }(0, e, o, n); return i ? (i = function formatContentAsBlockquote(t) { return t.split("\n").map((t => `> ${t}`)).join("\n"); }(i), `${r}\n${i}\n\n`) : ""; })).filter((t => t)).join(""), r; } catch (o) { return console.error("Error formatting conversation to Markdown:", o), ""; } } function loadScript(t, e) { return new Promise(((n, o) => { if (!e) { const n = t.split("/"), o = n[n.length - 1]; e = o.split(".")[0]; } console.debug(`Loading ${e}...`); const r = document.createElement("script"); r.src = t, r.onload = () => { console.info(`${e} loaded successfully`), n(); }, r.onerror = () => o(new Error(`Failed to load script ${e}`)), document.head.appendChild(r); })); } async function downloadChatsAsZip(t) { "undefined" == typeof JSZip && await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js", "JSZip"); const e = new JSZip, n = t.sessions.map((t => getChatHistory(t.uuid).then((e => ({ ...e, title: t.title }))))), o = await Promise.all(n)["catch"]((t => { throw console.error("Error fetching chat histories:", t), new Error("Failed to fetch chat histories"); })); o.forEach((t => { const n = formatConversationMarkdown(t), o = t.title.replace(/[<>:"\/\\|?*]+/g, "").trim(); e.file(`${o}.md`, n); })), "undefined" == typeof saveAs && await loadScript("https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js", "FileSaver"); const r = await e.generateAsync({ type: "blob" }); try { const t = function askUserForFilename(t = "DeepAIChats.zip") { let e = prompt("Please enter a filename for the downloaded zip file:", t); return e && e.trim() ? (e.endsWith(".zip") || (e += ".zip"), e.trim()) : t; }(); window.saveAs(r, t); } catch (i) { console.error("Error during file save:", i), window.saveAs(r, "DeepAIChats.zip"); } } !async function downloadChatsAsZippedMarkdown() { chatData = await getMyChatSessionsAndConvertAnonymousSessions(), await downloadChatsAsZip(chatData); }();
